{
  "name": "node-etcd",
  "version": "4.1.0",
  "description": "etcd library for node.js (etcd v2 api)",
  "licenses": [
    {
      "type": "BSD 3-Clause",
      "url": "http://opensource.org/licenses/BSD-3-Clause"
    }
  ],
  "maintainers": [
    {
      "name": "Stian Eikeland",
      "email": "stian@eikeland.se",
      "url": "http://eikeland.se/"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/stianeikeland/node-etcd.git"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "main": "lib/index.js",
  "scripts": {
    "build": "coffee --bare --compile --output lib/ src/*.coffee",
    "prepublish": "coffee --bare --compile --output lib/ src/*.coffee",
    "postpublish": "rm -rf lib",
    "test": "mocha --compilers coffee:coffee-script/register test/",
    "watch": "mocha --compilers coffee:coffee-script/register --watch"
  },
  "dependencies": {
    "underscore": "~1.8.2",
    "request": "~2.60.0",
    "deasync": "~0.0.10"
  },
  "devDependencies": {
    "coffee-script": "~1.9.1",
    "mocha": "~2.1.0",
    "nock": "~0.59.0",
    "should": "~5.0.1"
  },
  "keywords": [
    "etcd",
    "raft"
  ],
  "readme": "# node-etcd\n\nA nodejs library for [etcd](http://github.com/coreos/etcd), written in coffee-script.\n\n[![NPM](https://nodei.co/npm/node-etcd.png?downloads=true&stars=true)](https://nodei.co/npm/node-etcd/)\n\nTravis-CI: [![Build Status](https://travis-ci.org/stianeikeland/node-etcd.png?branch=master)](https://travis-ci.org/stianeikeland/node-etcd)\n\n## Install\n\nFor nodejs >= 0.10 and iojs:\n\n```\n$ npm install node-etcd\n```\n\nFor nodejs == 0.8:\n\n```\n$ npm install node-etcd@3.0.2\n```\n\n## Changes\n\n- 4.1.0\n  - Bumps request[https://github.com/request/request] library version to\n  v2.60.0, this solves an issue with HTTP proxies. `HTTP_PROXY` and `NO_PROXY`\n  env variables should now work as expected for all requests. See issue #40\n- 4.0.2\n  - 307 redirects from etcd 0.4.x clusters when using SSL didn't work properly\n  because of a change in the underlying request library. See issue #39\n- 4.0.1\n  - Minor fixes for syncronous operations, better handling of server failure.\n- 4.0.0\n  - Adds support for synchronous operations (@brockwood) - See\n    [Synchronous Operations](#synchronous-operations).\n  - Adds support for iojs.\n  - Drops support for nodejs 0.8 (use v3.x.x).\n  - Upgrade dependencies.\n- 3.0.2 - Handle cluster leader election periods better (etcd will disconnect us\n  and reject new connections until a new leader is chosen). The client will now\n  retry 3 times with exp backoff if it believes a cluster election is in\n  progress. Retry count is controllable via the `{ maxRetries: x }` option for a\n  request. (npm failed on me and I had to publish as 3.0.2)\n- 3.0.0 - Added cluster support, library now accepts a list of servers to\n  connect to, see constructor changes below. All requests now return a\n  cancellation token, meaning you can cancel requests by calling .cancel() or\n  .abort(). This release might break something if you've previously depended on\n  the leaky abstraction to the request library (request object from request\n  library was returned on all api calls - this has been replaced by the\n  cancellation token - the current request is still available under .req on the\n  token if you really need it.).\n- 2.1.5 - Watcher: try to resync if etcd reports cleared index\n- 2.1.4 - Don't wait before reconnecting if Etcd server times out our watcher.\n- 2.1.3 - Etcd sends an empty response on timeout in recent versions. Parsing\n  the empty message caused watcher to emit error. Now it reconnects instead.\n- 2.1.2 - Exponential backoff (retry), fix spinning reconnect on error. (@ptte)\n- 2.1.1 - Increase request pool.maxSockets to 100\n- 2.1.0 - Use proper error objects instead of strings for errors.\n- 2.0.10 - Fix error in documentation\n- 2.0.9 - Added .post() alias of .create(). Added .compareAndDelete() (for etcd v0.3.0)\n- 2.0.8 - Watchers can be canceled. In-order keys using #create(). Raw requests using #raw().\n- 2.0.7 - Avoid calling callback if callback not given.\n- 2.0.6 - Refactoring, fix responsehandler error.\n- 2.0.5 - Undo use of 'x-etcd-index', this refers to global state.\n- 2.0.4 - Use 'x-etcd-index' for index when watching a key.\n- 2.0.3 - Watcher supports options. Watcher emits etcd action type.\n- 2.0.2 - Mkdir and rmdir. Fix watcher for v2 api.\n- 2.0.1 - Watch, delete and stats now use new v2 api. Added testAndSet convenience method.\n- 2.0.0 - Basic support for etcd protocol v2. set, get, del now supports options.\n- 0.6.1 - Fixes issue #10, missing response caused error when server connection failed / server responded incorrectly.\n- 0.6.0 - Watcher now emits 'error' on invalid responses.\n\n## Basic usage\n\n```javascript\nEtcd = require('node-etcd');\netcd = new Etcd();\netcd.set(\"key\", \"value\");\netcd.get(\"key\", console.log);\n```\n\n## Methods\n\n### Etcd([host = '127.0.0.1'], [port = '4001'], [ssloptions])\n\nCreate a new etcd client for a single host etcd setup\n\n```javascript\netcd = new Etcd();\netcd = new Etcd('127.0.0.1', '4001');\n```\n\n### Etcd(hosts, [ssloptions])\n\nCreate a new etcd client for a clustered etcd setup. Client will connect to\nservers in random order. On failure it will try the next server. When all\nservers have failed it will callback with error. If it suspects the cluster is\nin leader election mode it will retry up to 3 times with exp backoff. Number of\nretries can be controlled by adding `{ maxRetries: x }` as an option to requests.\n\n```javascript\netcd = new Etcd(['127.0.0.1:4001','192.168.1.1:4001']);\n```\n\n### .set(key, value = null, [options], [callback])\n\nSet key to value, or create key/directory.\n\n```javascript\netcd.set(\"key\");\netcd.set(\"key\", \"value\");\netcd.set(\"key\", \"value\", console.log);\netcd.set(\"key\", \"value\", { ttl: 60 }, console.log);\netcd.set(\"key\", \"value\", { maxRetries: 3 }, console.log);\n```\n\nAvailable options include:\n\n- `ttl` (time to live in seconds)\n- `prevValue` (previous value, for compare and swap)\n- `prevExist` (existance test, for compare and swap)\n- `prevIndex` (previous index, for compare and swap)\n\nWill create a directory when used without value (value=null): `etcd.set(\"directory/\");`\n\n### .compareAndSwap(key, value, oldvalue, [options], [callback])\n\nConvenience method for test and set (set with {prevValue: oldvalue})\n\n```javascript\netcd.compareAndSwap(\"key\", \"newvalue\", \"oldvalue\");\netcd.compareAndSwap(\"key\", \"newValue\", \"oldValue\", options, console.log);\n```\n\nAlias: `.testAndSet()`\n\n### .get(key, [options], [callback])\n\nGet a key or path.\n\n```javascript\netcd.get(\"key\", console.log);\netcd.get(\"key\", { recursive: true }, console.log);\n```\n\nAvailable options include:\n\n- `recursive` (bool, list all values in directory recursively)\n- `wait` (bool, wait for changes to key)\n- `waitIndex` (wait for changes after given index)\n\n### .del(key, [options], [callback])\n\nDelete a key or path\n\n```javascript\netcd.del(\"key\");\netcd.del(\"key\", console.log);\netcd.del(\"key/\", { recursive: true }, console.log);\n```\n\nAvailable options include:\n\n- `recursive` (bool, delete recursively)\n\nAlias: `.delete()`\n\n### .compareAndDelete(key, oldvalue, [options], [callback])\n\nConvenience method for test and delete (delete with {prevValue: oldvalue})\n\n```javascript\netcd.compareAndDelete(\"key\", \"oldvalue\");\netcd.compareAndDelete(\"key\", \"oldValue\", options, console.log);\n```\n\nAlias: `.testAndDelete()`\n\n### .mkdir(dir, [options], [callback])\n\nCreate a directory\n\n```javascript\netcd.mkdir(\"dir\");\netcd.mkdir(\"dir\", console.log);\netcd.mkdir(\"dir/\", options, console.log);\n```\n\n### .rmdir(dir, [options], [callback])\n\nRemove a directory\n\n```javascript\netcd.rmdir(\"dir\");\netcd.rmdir(\"dir\", console.log);\netcd.rmdir(\"dir/\", { recursive: true }, console.log);\n```\n\nAvailable options include:\n\n- `recursive` (bool, delete recursively)\n\n### .create(path, value, [options], [callback])\n\nAtomically create in-order keys.\n\n```javascript\netcd.create(\"queue\", \"first\")\netcd.create(\"queue\", \"next\", console.log)\n```\n\nAlias: `.post()`\n\n### .watch(key, [options], [callback])\n\nThis is a convenience method for get with `{wait: true}`.\n\n```javascript\netcd.watch(\"key\");\netcd.watch(\"key\", console.log);\n```\n\nThe watch command is pretty low level, it does not handle reconnects or\ntimeouts (Etcd will disconnect you after 5 minutes). Use the `.watcher()` below\nif you do not wish to handle this yourself.\n\n### .watchIndex(key, index, [options], callback)\n\nThis is a convenience method for get with `{wait: true, waitIndex: index}`.\n\n```javascript\netcd.watchIndex(\"key\", 7, console.log);\n```\n\nSee `.watch()` above.\n\n### .watcher(key, [index], [options])\n\nReturns an eventemitter for watching for changes on a key\n\n```javascript\nwatcher = etcd.watcher(\"key\");\nwatcher.on(\"change\", console.log); // Triggers on all changes\nwatcher.on(\"set\", console.log);    // Triggers on specific changes (set ops)\nwatcher.on(\"delete\", console.log); // Triggers on delete.\nwatcher2 = etcd.watcher(\"key\", null, {recursive: true});\nwatcher2.on(\"error\", console.log);\n```\n\nYou can cancel a watcher by calling `.stop()`.\n\nSignals:\n- `change` - emitted on value change\n- `reconnect` - emitted on reconnect\n- `error` - emitted on invalid content\n- `<etcd action>` - the etcd action that triggered the watcher (ex: set, delete).\n- `stop` - watcher was canceled.\n- `resync` - watcher lost sync (server cleared and outdated the index).\n\nIt will handle reconnects and timeouts for you, it will also resync (best\neffort) if it loses sync with Etcd (Etcd only keeps 1000 items in its event\nhistory - for high frequency setups it's possible to fall behind).\n\nUse the `.watch()` command in you need more direct control.\n\n### .raw(method, key, value, options, callback)\n\nBypass the API and do raw queries.\nMethod must be one of: PUT, GET, POST, PATCH, DELETE\n\n```javascript\netcd.raw(\"GET\", \"v2/stats/leader\", null, {}, callback)\netcd.raw(\"PUT\", \"v2/keys/key\", \"value\", {}, callback)\n```\n\nRemember to provide the full path, without any leading '/'\n\n### .machines(callback)\n\nReturns information about etcd nodes in the cluster\n\n```javascript\netcd.machines(console.log);\n```\n\n### .leader(callback)\n\nReturn the leader in the cluster\n\n```javascript\netcd.leader(console.log);\n```\n\n### .leaderStats(callback)\n\nReturn statistics about cluster leader\n\n```javascript\netcd.leaderStats(console.log);\n```\n\n### .selfStats(callback)\n\nReturn statistics about connected etcd node\n\n```javascript\netcd.selfStats(console.log);\n```\n\n## Synchronous operations\n\nThe library supports a set of basic synchronous/blocking operations that can be useful during\nprogram startup (used like [fs.readFileSync](http://nodejs.org/api/fs.html#fs_fs_readfilesync_filename_options)).\n\nSynchronous functions perform the etcd request immediately (blocking) and return the following:\n\n```javascript\n{\n  err // Error message or null if request completed successfully\n  body // Body of the message or null if error\n  headers // Headers from the response\n}\n```\n\n### .setSync(key, value = null, [options])\n\nSynchronously set key to value, or create key/directory.\n\n```javascript\netcd.setSync(\"key\");\netcd.setSync(\"key\", \"value\");\netcd.setSync(\"key\", \"value\", { ttl: 60 });\netcd.setSync(\"key\", \"value\", { maxRetries: 3 });\n```\n\nSame options and function as .set().\n\n### .getSync(key, [options])\n\nGet a key or path.\n\n```javascript\netcd.getSync(\"key\");\netcd.getSync(\"key\", { recursive: true });\n```\n\n### .delSync(key, [options])\n\nSynchronously delete a key or path\n\n```javascript\netcd.delSync(\"key\");\netcd.delSync(\"key/\", { recursive: true });\n```\n\nThe available options are the same as .del() above.\n\n### .mkdirSync(dir, [options])\n\nSynchronously create a directory\n\n```javascript\netcd.mkdirSync(\"dir\");\netcd.mkdirSync(\"dir/\", options);\n```\n\n### .rmdirSync(dir, [options])\n\nSynchronously remove a directory\n\n```javascript\netcd.rmdirSync(\"dir\");\netcd.rmdirSync(\"dir/\", { recursive: true });\n```\n\nThe available options are the same as .rmdir() above.\n\n## Aborting a request\n\nAll async requests will return a cancellation token, to abort a request, do\nthe following:\n\n```javascript\nvar token = etcd.get(\"key\", console.log);\ntoken.abort() // also aliased as token.cancel()\n\nconsole.log(\"Request is cancelled: \", token.isAborted());\n```\n\nNote that there are no guarantees that aborted write operations won't have\naffected server state before they were aborted. They only guarantee here is that\nyou won't get any callbacks from the request after calling `.abort()`.\n\n## SSL support\n\nPass etcdclient a dictionary containing ssl options, check out http://nodejs.org/api/https.html#https_https_request_options_callback\n\n```javascript\nfs = require('fs');\n\nsslopts = {\n\tca: [ fs.readFileSync('ca.pem') ],\n\tcert: fs.readFileSync('cert.pem'),\n\tkey: fs.readFileSync('key.pem')\n};\n\netcdssl = new Etcd('localhost', '4001', sslopts);\n```\n\n## FAQ:\n\n- Are there any order of execution guarantees when doing multiple requests without using callbacks?\n    - No, order of execution is up to NodeJS and the network. Requests run from a connection pool, meaning that if one request is delayed for some reason they'll arrive at the server out of order. Use callbacks (and maybe even a nice [async](https://github.com/caolan/async) callback handling library for convenient syntax) if ordering is important to prevent race conditions.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/stianeikeland/node-etcd/issues"
  },
  "homepage": "https://github.com/stianeikeland/node-etcd",
  "_id": "node-etcd@4.1.0",
  "_from": "node-etcd@^4.0.2"
}
